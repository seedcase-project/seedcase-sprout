---
title: "Creating and managing data resources"
order: 2
jupyter: python3
---

In each [data package](/docs/glossary.qmd) are [data
resources](/docs/glossary.qmd), which contain conceptually standalone
sets of data. This page shows you how to create and manage data
resources inside a data package using Sprout. You will need to have
already [created a data package](packages.qmd#creating-a-data-package).

{{< include _preamble.qmd >}}

::: callout-important
Data resources can only be created from [tidy
data](https://design.seedcase-project.org/data/) in [Polars
DataFrames]((https://pola.rs/)). Before you can store it, you need to
process it into a tidy format, ideally using Python so that you have a
record of the steps taken to clean and transform the data.
:::

The steps you'll take to get your data into the structure used by Sprout
are:

<!-- TODO: update when finished with updating the rest of the guide -->

1.  Create the properties for the resource, using the original data as a
    starting point, and edit the resource properties script as needed.
2.  Create the folders for the new resource within the package and save
    the resource properties in the `datapackage.json` file.
3.  Add your data to the batches of data for the resource.
4.  Merge the data batches into a new resource data file.
5.  Re-build the data package's `README.md` file from the updated
    `datapackage.json` file.
6.  If you need to update the properties at a later point, you can use
    `update_resource_properties()` and then write the result to the
    `datapackage.json` file.

{{< include _python-minimal-package-setup.qmd >}}

```{python setup}
#| include: false
# This `setup` code chunk sets up the package from the packages guide and downloads some data.
import polars as pl
from tempfile import TemporaryDirectory, mkdtemp
from urllib.request import urlretrieve

package_path = sp.PackagePath(package_path)

package_properties = sp.example_package_properties()
sp.create_properties_script(package_path.root())

sp.write_properties(
    properties=package_properties,
    path=package_path.properties(),
)
readme = sp.as_readme_text(package_properties)
sp.write_file(readme, package_path.readme())

# TODO: Maybe eventually move this over into Sprout as an example dataset, rather than via a URL.
# Download the example data to a temporary location.
url = "https://raw.githubusercontent.com/seedcase-project/data/refs/heads/main/patients/patients.csv"
raw_data_path = package_path.root() / "rawdata" / "patients.csv"
raw_data_path.parent.mkdir(exist_ok=True)
urlretrieve(
    url,
    raw_data_path
)

raw_data_patients = pl.read_csv(raw_data_path)
```

Making a data resource requires that you have data that can be made into
a resource in the first place. Usually, generated or collected data
starts out in a bit of a "raw" shape that needs some working. This work
needs to be done before adding the data to a data package, since Sprout
assumes that the data is already
[tidy](https://design.seedcase-project.org/data/).

For this guide, you will use (fake) data that is already tidy. You can
find the data
[here](https://raw.githubusercontent.com/seedcase-project/data/refs/heads/main/patients/patients.csv).
We've placed this data in a `rawdata/` folder in the data package and
called it `patients.csv`, so that we can keep the original data separate
from the processed data.

`patients.csv` includes data about patients with diabetes, and it looks
like this:

```{python}
#| echo: false
raw_data_patients.head(5)
```

At this point, your data package `diabetes-study` has the following
structure:

```{python}
#| echo: false
print(file_tree(package_path.root()))
```

## Extracting resource properties from the data

Before you can store resource data in your data package, you need to
describe its [properties](/docs/glossary.qmd). The resource's properties
are what allow other people to understand what your data is about and to
use it more easily.

The resource's properties also define what it means for data in the
resource to be correct, as all data in the resource must match the
properties. Sprout checks that the properties are correctly filled in
and that no required properties fields are missing. It also checks that
the data matches the properties, so that you can be sure that data
actually contains what you expect it to contain.

Like with the package properties, you will create a properties script
for the resource that allows you to easily edit the properties later on.
You can do this by using the `create_properties_script()` function. This
function needs the `resource_name` and optionally the `fields` (i.e.,
columns or variables) that you want to include in the resource.

The `resource_name` is the name of the resource, which is used to
identify the resource in the data package. It is required and *should
not* be changed, since it's used in the file name of the resource
properties script. Since a data package can contain multiple resources,
the resource `name` must also be unique.

To ease the process of adding `fields` to your resource properties,
Sprout provides a function called `extract_field_properties()` which
allows you to extract information from the Polars DataFrame with your
data to have some initial properties. Use these extracted properties as
a starting point and edit as needed.

::: callout-warning
`extract_field_properties()` extracts the field properties from the
Polars DataFrame's \[schema\] and maps the Polars data type to a [Data
Package field
type](https://datapackage.org/standard/table-schema/#field-types).

The mapping is not perfect, so you may need to edit the extracted
properties to ensure that they are as you want them to be.
:::

Let's add these steps to our `main.py` file: First, we need to load the
original data from the `rawdata/` folder into a Polars DataFrame, then
we can extract the field properties from it, and use these properties in
the creation of our resource properties script:

```python
import polars as pl

def main():
    # Your existing code here...

    # Load the "patients" raw data from the CSV file.
    raw_data_patients = pl.read_csv(package_path.root() / "rawdata" / "patients.csv")
    # Extract field properties.
    field_properties = sp.extract_field_properties(
        data=raw_data_patients,
    )
    # Create the resource properties script.
    sp.create_resource_properties_script(
        resource_name="patients",
        fields=field_properties,
    )

if __name__ == "__main__":
    main()
```

Then run the `main.py` file in your Terminal to create the resource
properties script:

``` {.bash filename="Terminal"}
uv run main.py
```

```{python}
#| include: false
raw_data_patients = pl.read_csv(package_path.root() / "rawdata" / "patients.csv")
field_properties = sp.extract_field_properties(data=raw_data_patients)
sp.create_resource_properties_script(
        resource_name="patients",
        fields=field_properties,
        path=package_path.root()
    )
```


To see the contents of the newly created resource properties script,
open the `scripts/resource_properties_patients.py` file on your
computer. It should look like this:

::: {.callout collapse="true"}
## Full content of the `resource_properties_patients.py` file

```{python}

import seedcase_sprout as sp

resource_properties_patients = sp.ResourceProperties(
    ## Required:
    name="patients",
    title="",
    description="",
    ## Optional:
    type="table",
    format="parquet",
    mediatype="application/parquet",
    schema=sp.TableSchemaProperties(
        ## Required
        fields=[
            sp.FieldProperties(
                ## Required
                name="id",
                type="integer",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="age",
                type="integer",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="sex",
                type="string",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="height",
                type="number",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="weight",
                type="number",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="diabetes_type",
                type="string",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
        ],
        ## Optional
        # fields_match=["equal"],
        # primary_key=[""],
        # unique_keys=[[""]],
        # foreign_keys=[
        #     sp.TableSchemaForeignKeyProperties(
        #         ## Required
        #         fields=[""],
        #         reference=sp.ReferenceProperties(
        #             ## Required
        #             resource="",
        #             fields=[""],
        #         ),
        #     ),
        # ],
    ),
    # sources=[
    #     sp.SourceProperties(
    #         ## Required:
    #         title="",
    #         ## Optional:
    #         path="",
    #         email="",
    #         version="",
    #     ),
    # ],
)
```
:::

In the resource properties script, the `name` property is set to
`patients`. However, the two other required properties, `title` and
`description`, are empty. You will need to fill these in yourself in the
script, like so:

```{python}
#| eval: false
resource_properties_patients = sp.ResourceProperties(
    ## Required:
    name="patients",
    title="Patients Data",
    description="This data resource contains data about patients in a diabetes study.",
    ## Optional:
    # Rest of the properties...
)
```

::: callout-warning
## `CheckError` when properties are not filled in

If the `title` and `description` properties are not filled in, Sprout
will raise a `CheckError` when try to include the resource's properties
in the `datapackage.json` file.

Below you can see how `CheckErrors` look like when you try to check the
resource properties without filling in the required fields.

The used function `check_resource_properties()` checks that the
properties are correctly filled in and that no required fields are
missing. It's used internally in Sprout to ensure that the properties
are correct before writing them to the `datapackage.json` file.

```{python}
#| error: true
#| eval: false
print(sp.check_resource_properties(resource_properties_patients))
```

```
  +-+---------------- 1 ----------------
    | seedcase_sprout.check_datapackage.check_error.CheckError: Error at `$.description` caused by `blank`: The 'description' field is blank, please fill it in.
    +---------------- 2 ----------------
    | seedcase_sprout.check_datapackage.check_error.CheckError: Error at `$.title` caused by `blank`: The 'title' field is blank, please fill it in.
    +------------------------------------
```
:::

Now, the resource properties for patients include the following
information (printed as a dictionary representation that omits empty
fields):

```{python}
#| echo: false
resource_properties_patients = sp.ResourceProperties(
    ## Required:
    name="patients",
    title="Patients Data",
    description="This data resource contains data about the patients included in the diabetes study.",
    ## Optional:
    type="table",
    format="parquet",
    mediatype="application/parquet",
    schema=sp.TableSchemaProperties(
        ## Required
        fields=[
            sp.FieldProperties(
                ## Required
                name="id",
                type="integer",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="age",
                type="integer",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="sex",
                type="string",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="height",
                type="number",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="weight",
                type="number",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
            sp.FieldProperties(
                ## Required
                name="diabetes_type",
                type="string",
                ## Optional
                # title="",
                # format="",
                # description="",
                # example="",
                # categories=[],
                # categories_ordered=False,
            ),
        ],
        ## Optional
        # fields_match=["equal"],
        # primary_key=[""],
        # unique_keys=[[""]],
        # foreign_keys=[
        #     sp.TableSchemaForeignKeyProperties(
        #         ## Required
        #         fields=[""],
        #         reference=sp.ReferenceProperties(
        #             ## Required
        #             resource="",
        #             fields=[""],
        #         ),
        #     ),
        # ],
    ),
    # sources=[
    #     sp.SourceProperties(
    #         ## Required:
    #         title="",
    #         ## Optional:
    #         path="",
    #         email="",
    #         version="",
    #     ),
    # ],
)
```

```{python}
sp.pprint(resource_properties_patients.compact_dict)
```

<!-- TODO: pprint doesn't work well with nested objects like resource_properties above.
So, for now, we'll use a compact dict representation  here. but, we should find an alternative.
 -->

To include these properties in your data package, you need to include
the resource properties in the `properties.py` file of your data
package. You can do this by adding the following lines to the
`properties.py` file:

```{python}
#| eval: false
# Below the existing imports, add:
from .resource_properties_patients import resource_properties_patients

properties = sp.PackageProperties(
    # Your existing properties here...
    # Uncomment the resource properties line below and add `resource_properties_patients`:
    resources=[
        resource_properties_patients,
    ],
)
```

## Creating a data resource

Now that you have the properties for the resource, you can create the
properties for the resource within your existing data package. A data
package can contain multiple resources, so their `name` property
must be unique. This `name` property is what will be used later
to create the folder structure for that resource.

We assume that you've already created a data package (for example, by
following the [package guide](packages.qmd#creating-a-data-package)) and
stored the path to it as a `PackagePath` object in the `package_path`
variable. In this guide, the root folder of the package is in a
temporary folder:

```{python}
print(package_path.root())
```

Let's take a look at the current files and folders in the data package:

```{python}
#| echo: false
print(file_tree(package_path.root()))
```

This shows that the data package already includes a `datapackage.json`
file and a `README.md` file.

The next step is to write the resource properties to the
`datapackage.json` file. Before they are added, they will be checked to
confirm that they are correctly filled in and that no required fields
are missing. You can use the `PackagePath().properties()` helper
function to give you the location of the `datapackage.json` file based
on the path to your package.

```{python}
#| eval: false
# TODO: Update to use template when it has been implemented
sp.write_properties(
    properties=properties,
    path=package_path.properties(),
)
```

Let's check the contents of the `datapackage.json` file to see that the
resource properties have been added:

```{python}
print(sp.read_properties(package_path.properties()))
```

<!-- TODO: pprint doesn't work well with nested objects like resource_properties above.
So, for now, we'll use print here. but, we should find an alternative.
 -->

## Storing a backup of the data as a batch file

::: callout-note
See the [flow diagrams](/docs/design/interface/flows.qmd#flows) for a
simplified flow of steps involved in adding batch files.
:::

Batch files are used to store data in a data package each time you add
data to a resource. These batch files will be used to create the data
file that is actually used as the resource at the path
`resource/<name>/data.parquet`. The first time a batch file is saved, it
will create the folders necessary for the resource.

As shown above, the data is currently stored loaded as a Polars
DataFrame called `data`. Now, it's time to store this data in the
resource's folder by using:

<!-- TODO: Convert to save to temp location -->

```{python}
sp.write_resource_batch(
    data=raw_data_patients,
    resource_properties=resource_properties_patients,
)
```

This function uses the properties object to determine where to store the
data as a batch file, which is in the `batch/` folder of the resource's
folder. If this is the first time adding a batch file, all the folders
will be set up. You can check the newly added file by using:

```{python}
print(package_path.resource_batch_files(1))
```

## Building the resource data file

Now that you've stored the data as a batch file, you can build the
Parquet file that will be used as the data resource. This Parquet file
is built from all the data in the `batch/` folder. Since there is only
one batch data file stored in the resource's folder, only this one will
be used to build the data resource's Parquet file:

```{python}
#| eval: false
# TODO: eval when function implemented
sp.join_resource_batches(
    data_list=...,
    resource_properties=resource_properties
)
```

::: callout-tip
If you add more data to the resource later on, you can update this
Parquet file to include all data in the batch folder using the
`build_resource_parquet()` function like shown above.
:::

## Re-building the README file

One of the last steps to adding a new data resource is to re-build the
`README.md` file of the data package. To allow some flexibility with
what gets added to the README text, this next function will only *build
the text*, but not write it to the file. This allows you to add
additional information to the README text before writing it to the file.

```{python}
readme_text = sp.as_readme_text(
    properties=sp.read_properties(package_path.properties())
)
```

For this guide, you'll only use the default text and not add anything
else to it. Next you write the text to the `README.md` file by:

```{python}
sp.write_file(
    string=readme_text,
    path=package_path.readme()
)
```

## Updating resource properties

After having created a resource, you may need to make edits to the
properties. While technically you can do this manually by opening up the
`datapackage.json` file and editing it, we strongly recommend you use
the update functions to do this. These functions help to ensure that the
`datapackage.json` file is still in a correct JSON format and has the
correct fields filled in. You can call the
`update_resource_properties()` function with two arguments: the current
resource properties and a resource properties object representing the
updates you want to make. This latter object will very often be a
partial resource properties, in the sense that it will have only those
fields filled in that you want to update. The function will return an
updated resource properties object. Any field in the object representing
the updates will overwrite the corresponding field in the current
properties object.

```{python}
#| eval: false
# TODO: eval when function implemented
resource_properties = sp.update_resource_properties(
    current_properties=resource_properties,
    update_properties=sp.ResourceProperties(
        title="Basic characteristics of patients"
    )
)
pprint(resource_properties)
```

Finally, to write your changes back to `datapackage.json`, use the
`write_properties()` function:

```{python}
#| eval: false
# TODO: Update to use template when it has been implemented
sp.write_properties(
    properties=properties,
    path=package_path.properties(),
)
```

```{python}
#| include: false
import shutil

if Path(temp_path.name).exists():
    shutil.rmtree(Path(temp_path.name))
```
